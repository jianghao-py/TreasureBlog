### 字符串运算符 （字符串拼接）

```javascript
var foo = 'Hello' + ' ' + 'world!';

console.log(foo);
// 'Hello world!'
```

<br>

<br>


### 算术运算符

- ```+``` ： 1 + 1 = 2
- ```-``` ： 2 - 1 = 0
- ```*```
- ```/```
- ```%```
- ``++``：前自增（先自增后赋值），后自增（先赋值后自增）
- ``--``：前自减（先自减后赋值），后自减（先赋值后自减）
- ``**``：次方
- ```-```：一元负值符，返回操作数的负值 （```-a```）
- ```+```：一元正值符，若操作数在操作前非数字类型，将试图将其转换成数字类型 （```+a```）


<br>

<br>

### 位运算移位运算符


<br>

<br>


### 逗号运算符

<br>

<br>

### 比较运算符

```
- >
- <
- =
- >=
- <=
- ==
- !=
- ===   两边操作数相等且类型相同时返回 true （会进行类型转换）
- !===  两边操作数不相等或类型不同时返回 true
```

<br>

<br>

### 逻辑运算符

- ```&&``` （逻辑与）：只有在两个操作数都为 true 时，结果才返回 true
    - 逻辑与操作属于 **短路操作**，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值
    - 如果第一个操作数是 false，则无论第二个操作数是什么值，结果都是 false，则返回第一个操作数
    - 如果第一个操作数为 true，**则直接返回第二个操作数**
    - 逻辑与操作可以应用于任何类型的操作数

```javascript
var e = 'Cat' && 'Dog';
// 'Dog'

var f = false && 'Cat';
// false

var g = 'Cat' && false;
// false
```

<br>

- ```||``` （逻辑或）：只有在两个操作数都是 false 时，结果才返回 false，否则返回 true
  - 逻辑或操作也可以应用于任何类型的操作数
  - 逻辑或操作也属于**短路操作**，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值
  - 如果第一个操作数是 true，则无论第二个操作数是什么值，结果都是 true，直接返回第一个操作数
  - 如果第一个操作数是 false，则直接返回第二个操作数

<br>

- ```!``` （逻辑非）：逻辑非操作符首先会将它的操作数转换成一个布尔值，然后再对其求反


<br>

<br>

### 扩展运算符

1. 函数参数

```javascript
function add(a,b,c){
    return a + b + c;
}

let args = [1,2,3];

console.log(add(...args)); //6
```

2. 数组合并

```javascript
let arr = [3,4,5];

let newArr = [1,2,...arr];

console.log(newArr); //[1,2,3,4,5]
```

3. 数组的拷贝 （被拷贝数组元素仅限基本数据类型）

```javascript
let a = [1, 2, 3];
let b = [...a];
```

4. 字符串转为数组

```javascript
[...'hello'];
// ['h', 'e', 'l', 'l', 'o']
```

5. 任何 Iterator 接口的对象都可以用扩展运算符转为真正的数组



<br>

<br>

### 解构赋值

将 **值从数组** 或 **属性从对象** 提取到不同的变量中

<br>

**数组**

```javascript
var foo = [];

// 不使用解构
var one = foo[0];
var two = foo[1];
var three = foo[2];

// 使用解构
var [one, two, three] = foo;


let [foo, [[bar], baz]] = [1, [[2], 3]];
foo; // 1
bar; // 2
baz; // 3



let [, , third] = ['foo', 'bar', 'baz'];
third; // "baz"



let [x, y] = [1, 2, 3];
x; // 1
y; // 3



let [head, ...tail] = [1, 2, 3, 4];
head; // 1
tail; // [2, 3, 4]



let [x, y, ...z] = ['a'];
x; // "a"
y; // undefined
z; // []
```

<br>

**默认值**

```javascript
// 解构赋值允许指定默认值
let [x, y = 'b'] = ['a']; // x = 'a', y = 'b'
```

**默认值底层原理**

ES6 內部使用严格相等运算符（===）判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined ，默认值是不会生效的。

```javascript
let [x = 1] = [undefined];
x; // 1

// 默认值就不会生效，因为 null 不严格等于 undefined
let [x = 1] = [null];
x; // null
```

<br>

**如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在必须用到时才会求值**

```javascript
function f() {
  console.log('aaa');
}
let [x = f()] = [1];
```

<br>

<br>

**对象**

```javascript
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
foo; // 'aaa'
bar; // 'bbb'


let obj = {
  p: ['Hello', { y: 'World' }],
};

let {
  p,
  p: [x, { y }],
} = obj;
x; // 'Hello'
y; // 'World'
p; // ['Hello', { y: 'World'}]



var node = {
  loc: {
    start: {
      line: 1,
      column: 5,
    },
  },
};

var {
  loc,
  loc: { start },
  loc: {
    start: { line },
  },
} = node;
line; // 1

loc; // Object { start: Object }
start; // Object { line: 1, column: 5}



let arr = [1, 2, 3];
let { 0: first, [arr.length - 1]: last } = arr;
first; // 1
last; // 3
```

<br>

**用途**

```javascript
// 交换变量的值
let x = 1;
let y = 2;

[x, y] = [x, y];



// 提取 JSON 数据
let jsonData = {
  id: 42,
  status: 'ok',
  data: [867, 3509],
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "ok", [867, 5309]
```


